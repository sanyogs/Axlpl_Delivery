import 'dart:isolate';
import 'dart:ui';
import 'dart:io';
import 'dart:async';

import 'package:axlpl_delivery/app/data/localstorage/local_storage.dart';
import 'package:axlpl_delivery/common_widget/error_screen.dart';
import 'package:axlpl_delivery/common_widget/local_notification.dart';
import 'package:axlpl_delivery/common_widget/siren_alert_payload.dart';
import 'package:axlpl_delivery/firebase_options.dart';
import 'package:axlpl_delivery/utils/utils.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_downloader/flutter_downloader.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app/routes/app_pages.dart';

// core Flutter primitives
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  WidgetsFlutterBinding.ensureInitialized();
  DartPluginRegistrant.ensureInitialized();

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  await NotificationService.init(requestPermissions: false);
  NotificationService.showBackgroundNotification(message);
}

final LocalStorage _localStorage = LocalStorage();

@pragma('vm:entry-point')
void downloadCallback(String id, int status, int progress) {
  final SendPort? send =
      IsolateNameServer.lookupPortByName('downloader_send_port');
  send?.send([id, status, progress]);
}

// generated by
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

// Helper function to wait for APNS token on iOS
Future<void> _waitForAPNSToken(FirebaseMessaging messaging) async {
  try {
    // Try to get APNS token immediately
    String? apnsToken = await messaging.getAPNSToken();

    if (apnsToken != null) {
      Utils().log("APNS Token available: $apnsToken");
      return;
    }

    // If not available, wait with multiple retries
    int retryCount = 0;
    const maxRetries = 5;
    const retryDelay = Duration(seconds: 2);

    while (apnsToken == null && retryCount < maxRetries) {
      await Future.delayed(retryDelay);
      retryCount++;

      try {
        apnsToken = await messaging.getAPNSToken();
        if (apnsToken != null) {
          Utils()
              .log("APNS Token available after retry $retryCount: $apnsToken");
          return;
        } else {
          if (kDebugMode) {
            print('APNS Token not available, retry $retryCount/$maxRetries');
          }
        }
      } catch (e) {
        if (kDebugMode) {
          print('Error getting APNS token on retry $retryCount: $e');
        }
      }
    }

    if (apnsToken == null) {
      if (kDebugMode) {
        print(
            'APNS Token not available after $maxRetries retries. This is normal on iOS simulator.');
      }
    }
  } catch (e) {
    if (kDebugMode) {
      print('Error in APNS token setup: $e');
    }
  }
}

// Helper function to get FCM token
Future<void> _getFCMToken(FirebaseMessaging messaging) async {
  try {
    String? token = await messaging.getToken();
    if (token != null) {
      if (kDebugMode) {
        print("FCM Token: $token");
      }
      await storage.write(key: _localStorage.fcmToken, value: token);
    } else {
      if (kDebugMode) {
        print('FCM Token not available');
      }
    }
  } catch (e) {
    if (kDebugMode) {
      print('FCM Token not available yet: $e');
    }

    // For iOS, schedule a retry after a delay
    if (Platform.isIOS) {
      Timer(Duration(seconds: 5), () async {
        try {
          String? retryToken = await messaging.getToken();
          if (retryToken != null) {
            Utils().log("FCM Token (retry): $retryToken");
            await storage.write(key: _localStorage.fcmToken, value: retryToken);
          }
        } catch (retryError) {
          if (kDebugMode) {
            print('FCM Token retry failed: $retryError');
          }
        }
      });
    }
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  await NotificationService.init();

  final launchDetails = await NotificationService.getNotificationLaunchDetails();
  final launchPayload =
      SirenAlertPayload.tryDecode(launchDetails?.notificationResponse?.payload);
  if (launchPayload != null) {
    NotificationService.queueSirenLaunch(launchPayload);
  }

  final messaging = FirebaseMessaging.instance;
  final initialMessage = await messaging.getInitialMessage();
  if (initialMessage != null && NotificationService.isSirenMessage(initialMessage)) {
    NotificationService.queueSirenLaunch(
      NotificationService.buildSirenPayload(initialMessage),
    );
  }

  FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
    if (!NotificationService.isSirenMessage(message)) return;
    NotificationService.showSirenAlertScreen(
      NotificationService.buildSirenPayload(message),
    );
  });

  NotificationSettings settings = await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: false,
    provisional: false,
    sound: true, // enable sound for iOS
  );

  // iOS-specific setup
  if (Platform.isIOS) {
    print(
        "iOS notification permission status: ${settings.authorizationStatus}");

    await messaging.setForegroundNotificationPresentationOptions(
      alert: true,
      badge: true,
      sound: true,
    );
    print("iOS foreground notification options set");

    await _waitForAPNSToken(messaging);
    print("APNS token setup complete");
  }
  final DarwinInitializationSettings initSettingsIOS =
      DarwinInitializationSettings(
    requestAlertPermission: true,
    requestBadgePermission: true,
    requestSoundPermission: true,
  );

  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher');

  final InitializationSettings initSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initSettingsIOS,
  );
  await flutterLocalNotificationsPlugin.initialize(
    initSettings,
    onDidReceiveNotificationResponse: (NotificationResponse response) async {
      // Handle notification tapped when app is closed/background
    },
  );

  await FlutterDownloader.initialize(
    debug: true,
    ignoreSsl: true,
  );

  // Note: FlutterDownloader.registerCallback is called in ShipnowController where it's used

  // Listen for foreground messages and show local notification
  FirebaseMessaging.onMessage.listen((RemoteMessage message) {
    NotificationService.showNotification(message);
  });

  // Listen for FCM token refresh (APNS token available later on iOS)
  messaging.onTokenRefresh.listen((token) {
    if (kDebugMode) {
      print("FCM Token refreshed: $token");
    }
    storage.write(key: _localStorage.fcmToken, value: token);
  });

  // iOS-specific APNS token handling
  if (Platform.isIOS) {
    // Wait for APNS token to be available
    await _waitForAPNSToken(messaging);

    // Additional iOS-specific setup
    await messaging.setForegroundNotificationPresentationOptions(
      alert: true,
      badge: true,
      sound: true,
    );
  }

  // Try to get initial token, but don't fail if APNS token isn't ready
  await _getFCMToken(messaging);

  if (kDebugMode) {
    print('Permission granted: ${settings.authorizationStatus}');
  }

  // OneSignal.Debug.setLogLevel(OSLogLevel.verbose);
  // OneSignal.initialize("ff262d3f-067a-4c80-a370-08f18ed8b4c2");
  // OneSignal.Notifications.requestPermission(false);

  runApp(
    ScreenUtilInit(
      designSize: ScreenUtil.defaultSize,
      builder: (context, child) {
        return GetMaterialApp(
          debugShowCheckedModeBanner: false,
          enableLog: true,
          defaultTransition: Transition.noTransition,
          title: "AXLPL Delivery",
          builder: (context, child) {
            ErrorWidget.builder = (FlutterErrorDetails details) {
              return ErrorScreen();
            };

            final queuedSiren = NotificationService.consumeQueuedSirenLaunch();
            if (queuedSiren != null) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                NotificationService.showSirenAlertScreen(queuedSiren);
              });
            }

            if (Platform.isAndroid) {
              return SafeArea(child: child!);
            }
            return child!;
          },
          initialRoute: AppPages.INITIAL,
          getPages: AppPages.routes,
          theme: ThemeData(textTheme: GoogleFonts.workSansTextTheme()),
        );
      },
    ),
  );
}
